\xrtag{Creational}{Creational 创建型}
\chapter{Creational Pattern 创建型}

Creational design patterns abstract the instantiation process. They help make a system independent of how its objects are created, composed, and represented. A class creational pattern uses inheritacento vary the class that's instantiated, whereas an object creational pattern will delegate instantiation to another object.

创建型抽象了实例化的过程。他们使一个系统能够独立的创建、组合和表示。一个创建型类使用继承使其实例多样化，而一个创建型对象则将实例化委托给另一个对象。

\xrtag{AbstractFactory}{AbstractFactory 抽象工厂}
\section{AbstractFactory - 抽象工厂}

\textbf{Also known as 别名}

Kit

\subsection{Structure 结构}

\htmlpic{images/AbstractFactory.png}

在上图中AbstractFactory、AbstractProductA和AbstractProductB这三个抽象基类，分别派生出用来产生两种实际产品A和B的类厂1和2，经由这两个类厂的CreateProductA和CreateProductB方法使用AbstractProduct所派生出的两类具体产品家族来生产A和B所下辖1-2型产品。

\subsection{Participants 组成}

\begin{itemize}
\small
\item \textbf{AbstractFactory} (WidgetFactory)

	\begin{itemize}
		\item declares an interface for operations that create abstract product objects.
	\end{itemize}

\item \textbf{ConcreteFactory} (MotiWidgetFactory, PMWidgetFactory)
	
	\begin{itemize}
		\item  operations to create concrete product objects.
	\end{itemize}

\item \textbf{AbstractProduct} (Window, ScrollBar)

	\begin{itemize}
		\item declares an interface for a type of product object.
	\end{itemize}

\item \textbf{ConcreteProduct} (MotiWindow, MotiScrollBar)

	\begin{itemize}
		\item defines a product objects to be created by the corresponding concrete factory.

		\item implents the AbstractProduct interface.
	\end{itemize}

\item \textbf{Client} 

	\begin{itemize}
		\item  uses only interfaces decleared by AbstractFactory and AbstractProduct classes.
	\end{itemize}
\normalize
\end{itemize}

\subsection{Intent 意图} 

Provide an interfact for creating families of related or dependent objects without specifying their concrete classes.

在无需指定具象接口的情况下，提供了一个接口，用来创建一族互相关联或者依赖的对象。

\subsection{Applicability 适用性}

\begin{itemize}
\item A system should be independent of how its products are created, composed and represented.

      一个应当独立创建、组合和表示的系统。

\item A system should be configured with one of multiple families of products.

      一个应当由多个产品族类中的一个所配置的系统。

\item A family of related product objects is designed to be used together, and you need to enforce this constraint.

      一个被设计成协同使用并且需要强调其约束性的产品对象族。

\item You want to provide a class library of products, and you want to reveal just their interfaces, not their implementations.

      你想提供一个只暴露接口而非实现的产品类库。
\end{itemize}

\subsection{Consequences GoF评论}

\xrtag{AbstractFactory优缺点}{AbstractFactory"优缺点"}
The AbstractFactory pattern has the following benefits and liabilities:

抽象工厂模式有着如下的便利和负担：

\begin{enumerate}

\item It isolates concrete classes.

      抽象工厂分离了接口和实现。

\item It makes exchanging product families easy.
    
      产品有产品的共同抽象基类，工厂有各自工厂的抽象基类，他们的生命周期在C++中可以通过各自的基类指针统一管理。


\item It promotes consistency among products.

      拥有共同的抽象基类不同的产品系列可以经由共同的工厂抽象基类所派生出来的不同类厂所一致。

\item Supporting new kinds of products is difficult.

      AbstractFactory这个抽象基类最初的纯虚方法限制了所能产生的对象集合，在实际开发中如果扩展产品，需要修改基类和所有派生类的代码，导致维护代价和大规模代码重新编译的代价。
\end{enumerate}

\subsection{Implentation 实现}

\begin{enumerate}

\item Fatories as Singletons.

      若是应用中需要每个产品仅有一个实例存在，可使用Singleton模式。

\item Creating the products.

      如果有多个可能的产品系列，每个可能的产品系列虽然差别很小，仍需不同的工厂实现，因此可以考虑通过复制原型创建新的产品，参考Prototype模式实现。

\item Defining extensible factories.

      鉴于\ref{AbstractFactory优缺点}中提到的维护代价，有一种不够安全和良好的编码习惯，可以在构造时刻增加入参，来区别新的对象类型。对于C++这样的强类型语言来说，如果需要与特定的派生类别进行相关操作，而该操作又不能通过抽象接口所得到，用户可能会考虑使用dynamic—_cast转换，此举并非安全，因为可能会导致转换失败，这是权宜之计。

\end{enumerate}

\subsection{代码实现}

    先用头文件定义两个抽象基类，其中抽象工厂具有两个必须在派生类中被实现，抽象基类无需实现的纯虚函数，用来留给所派生的不同的工厂用自家的创造方法来重载。考虑到对象实例可能具有不同的销毁方式，定义了虚析构。
\scminput{code/Creational/AbstractFactory/AbstractFactory.h}
\scminput{code/Creational/AbstractFactory/AbstractTeenager.h}

    接下来普青产品经理和普青程序员有着共同的抽象基类，抽象青年。
\scminput{code/Creational/AbstractFactory/NormalTeenagerPM.h}
\scminput{code/Creational/AbstractFactory/NormalTeenagerPM.cpp}
\scminput{code/Creational/AbstractFactory/NormalTeenagerProgrammer.h}
\scminput{code/Creational/AbstractFactory/NormalTeenagerProgrammer.cpp}

    同样，文青产品经理和文青程序员也有着共同的抽象基类。
\scminput{code/Creational/AbstractFactory/LiteratureTeenagerPM.h}
\scminput{code/Creational/AbstractFactory/LiteratureTeenagerPM.cpp}
\scminput{code/Creational/AbstractFactory/LiteratureTeenagerProgrammer.h}
\scminput{code/Creational/AbstractFactory/LiteratureTeenagerProgrammer.cpp}

    现在派生出来一个专门生产产品经理的工厂。
\scminput{code/Creational/AbstractFactory/PMFactory.h}
\scminput{code/Creational/AbstractFactory/PMFactory.cpp}

    再派生一个专门生产程序员的工厂。
\scminput{code/Creational/AbstractFactory/ProgrammerFactory.h}
\scminput{code/Creational/AbstractFactory/ProgrammerFactory.cpp}

    两个工厂基类类型的指针指向两种不同的工厂实例，各种青年的一个容器，构造和析构
\scminput{code/Creational/AbstractFactory/client.cpp}

\xrtag{Build}{Builder 构建器}
\section{Builder - 构建器}

\subsection{Structure 结构}

\htmlpic{images/Builder.png}

图中Director的构造函数持有Builder基类指针，Director在构造时刻传入同样Builder指针所指向的不同派生类实例，使Director构造出来不同的具体对象。

\subsection{Participants 组成}

\begin{itemize}
\small
\item \textbf{Builder} (TextConverter)

	\begin{itemize}
		\item specifies an abstract interface for creating parts of a Product object.
	\end{itemize}

\item \textbf{ConcreteBuilder} (ASCIIConverter, TeXConverter, TextWidgetConverter)

	\begin{itemize}
		\item constructs and assembles parts of the product by implementing the Builder interface.

		\item defines and keeps track of the representation it creates.

		\item provides an interface for retrieving the product (e.g., GetASCIIText, GetTextWidget).
	\end{itemize}

\item \textbf{RTFReader}

	\begin{itemize}
		\item constructs an object using the Builder interface.
	\end{itemize}

\item \textbf{ASCIIText, TeXText, TextWidget}

	\begin{itemize}
		\item represents the complex object under construction. ConcreteBuilder builds the product's internal represrntation and defines the process by which it's assembled.

		\item includes classes that define the constituent parts, including interfaces for assembling the parts into final result.
	\end{itemize}
\normalize
\end{itemize}

\subsection{Intend 意图}

Separate the construction of a complex object from its representation so that the same construction process can create different representation.
分离复杂对象的构造和表现，以此达到通过同样构建过程创造不同表现的目的。

\subsection{Applicability 适用性}

\begin{itemize}
\item the algorithm for creating a complex object should be independent of the parts that make up the object and how they're assembled.

      当独立于对象组成和封装的某复杂对象算法。

\item the construction process must allow different representations for the object that's constructed.

      对象的构造过程必须要有不同的表现。
\end{itemize}

\subsection{Consequences GoF评论}

\begin{enumerate}

\item It lets you vary a product's internal presentation.

	  它通过给内建的导向器一个抽象接口，以达到一个构建的同时并隐藏这个产品的表示和内在结构的目的。改变产品的内在表示只需要定义一个新的构建器。

\item It isolates code for construction and representation. 

	 它的构造和表现代码是独立的。构建器模式通过封装复杂对象的构建和表示，产品更加模块化。

\item It gives you finer control over the construction process.

	  和一站式的创建型不同，构建器模式在导向器一步步的控制下完成。只有产品最终完成的时候，导向器才会从构建器中取回。构建器能够比其他创建型模式更好的反应产品的构造过程，使你能够在此过程中更好的循序控制产品构建的内在结果。

\end{enumerate}

\subsection{Implentation 实现}

Typically there's an abstract Builder class that defines an operation for each component that a director may ask it to create. The operations do nothing by default. A ConcreteBuilder class overrides operations for components it's interested in creating.

通常情况下，导向器可能会要求创建一个构建器类用来给每个组件定义一个操作。默认情况下什么都不做。一个ConcreteBuilder类重载了组件感兴趣的创建。

Here are other implementation issues to consider:

一些值得考虑的实现问题：

\begin{enumerate}

\item Assembly and contruction interface.

	  装配和构造接口。构建器通过产品形态一步步的构建产品，因此构建器类的接口必须足够通用以便于构造满足所有现实产品形态的构造。

	  一个关键问题是构造和装配过程的模型。只是简单的把构造请求追加到产品中通常已经足够，在RTF那个例子中，构建器转化下一个标记并且把它追加到已经在转换了的正文中。

	  但是一些时候你可能需要在构造以先访问部分产品。Maze的例子中，MazeBuilder允许在房间之间加门，语法分析树这样自底向上构建的树形结构就是另一个例子。在这种情况下，生成器会将子节点返给导向者，然后导向者将他们回传给构建器去创建父节点。

\item Why no abstract class for products?

	  为什么没有为产品准备抽象类？通常情况下，具体构建器产生的产品之间在表现形式上相去甚远，以至于在其间抽象出共同的基类得不偿失。在RTF那个例子里，ASCIIText和TextWidget两个对象之间看起来不象会有共同接口的样子，并不需要。因为客户通常将合适的具体的构建器配给导向者，客户就能够构建器的具体的那一个子类在使用和能够相应的处理产品。

\item Empty methods as default in Builder.

      构建器中默认为空的方法。在C++中，构建方法特地不声明为纯虚而是定义为空，这使用户只重载他们感兴趣的操作。

\end{enumerate}

\subsection{代码实现}

\scminput{code/Creational/Builder/Builder.h}
\scminput{code/Creational/Builder/ArabicBuilder.h}
\scminput{code/Creational/Builder/ArabicBuilder.cpp}
\scminput{code/Creational/Builder/EnglishBuilder.h}
\scminput{code/Creational/Builder/EnglishBuilder.cpp}
\scminput{code/Creational/Builder/Director.h}
\scminput{code/Creational/Builder/Director.cpp}
\scminput{code/Creational/Builder/Director.h}
\scminput{code/Creational/Builder/client.cpp}

\xrtag{FactoryMethod}{FactoryMethod 工厂方法}
\section{FactoryMethod 工厂方法}

\subsection{Structure 结构}

\htmlpic{images/Factory.png}

\textbf{ As known as 别名 }

虚构造器 ( Virtual Constructor )

\subsection{Participants 组成}

\begin{itemize}
\small

\item \textbf{Product} (Document)
	\begin{itemize}
		\item defines the interface of objects the factory method creates.
	\end{itemize}

\item \textbf{ConcreteProduct} (MyDocument)
	\begin{itemize}
		\item implements the Product interface.
	\end{itemize}

\item \textbf{Creator} (Application)
	\begin{itemize} 
		\item declares the factory method, which returns an object of type Product. Creator may also define a default Implentation of the factory method that returns a default ConcreteProduct object.

		\item may call the factory method to create a Product object.
	\end{itemize}

\item \textbf{ConcretCreator} (MyApplication)
	\begin{itemize}
		\item overrides the factory method to return an instance of a concreteProduct.
	\end{itemize}

\normalize
\end{itemize}

\subsection{Intend 意图}

Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.

定义一个创建对象的接口，让子类决定实例化哪个类。Facroty方法使一个类的实例化延迟到子类。

\subsection{Applicability 适用性}

工厂模式适用于：

\begin{itemize}

\item a class can't anticipate the class of objects it must create.
	
	  一个类无法预知他所必需创建的对象的类的时候。

\item a class wants its subclasses to specify the objects it creates.

	  一个类想要他的子类来指定他所创建的对象的时候。

\item classes delegate responsibility to one of several helper subclasses, and you want to localize the knowlege of which helper subclass is the delegate.

	  类将职责委托给一些帮助子类中的一个，并且你希望将谁是这个代理帮助子类的信息局部化。

\end{itemize}

\subsection{Consequences GoF评论}

工厂方法不再需要将特定应用相关的类绑定到你的代码中。代码只处理产品接口，虽然它可以和任何用户定义的ConcreteProduct类共同工作。

工厂方法的一个潜在缺点是客户可能必须派生Creator，以创建一个特定的ConcreteProduct对象。但当客户必须要处理类变化的其他方面，必需派生Creator时，这样也成。

下面是Factory Method模式的另外两种果效。

\begin{enumerate}

\item Provides hooks for subclasses.
      Hook子类。用工厂模式在一个类的内部创建对象总会比直接创建一个对象要灵活些。工厂方法挂接子类用以给对象提供一个扩展版本。

\item Connects parallel class hierarchies.
	  连接平衡的类层次。目前为止我们所看到的例子中，工厂方法只是被Creators调用。其实特别是在平行的类层次中，客户会发现工厂方法的用处。

	  一个类将它的一些职责委托给一个独立的类的时候，就产生了平行类层次。参考交互控制的图形图像，用鼠标对他们进行拉伸、移动或是旋转。实现这样的一些操作并不总是那么容易，这通常需要存储和更新在中间状态进行操作的一些记录。这些状态只是在操作中需要，在图形对象的最终存储时并不需要。更有甚者，不同的图形在用户操作的时候呈现不同的行为。例如，拉伸一条线段的时候可能出现的效果是移动线段的一个断点，而拉伸一个文本的时候可能会改变行距。

	  在这些限制之下，最好使用一个独立的Manipulator对象来实现交互并且保存特定的需要保存的轨迹状态。不同的图形通过使用不同的Manipuator子类来处理特殊的交互。最终Manipulator类层次平行于Figure，如图：

	  \htmlpic{images/FactoryConsequence.png}

	  Figure类提供了一个可以创建一个与Figure相对应的Manipulator的CreateManipulator工厂方法，Figure的子类重载了这个方法来返回一个恰当的Manipulator子类的实例。Figure类可以实现CreateManipulator来返回一个默认的Manipuator实例，Figure子类也可以简单的默认继承。Figure类并不需要响应Manipulator子类层次，因此他们是部分并行的。

	  注意工厂类如何定义两个类层次之间的关系，他将类之间的从属关系局部化了。

\end{enumerate}

\subsection{Implentation 实现}

Consider the following issues when applying the Factory Method pattern:

考虑工厂模式的如下两种状况：

\begin{enumerate}
	\item Two major varieties.

		  主要有两种不同情况：

		  \begin{enumerate}
		  		\item 在Creator是一个抽象类并且没有提供一个对他所声明的抽象方法的实现的时候。

				\item 在Creator是一个具体的类并且提供了工厂方法的默认实现的情况下。
		  \end{enumerate}

   		  第一种情况，需要子类来定义实现，因为没有合理的缺省市县。它避免了不得不实例化不可预见类的问题，第二种情况中，具体的Creator主要因为灵活性才使用工厂方法。它所遵循的准则是，“用一个独立的操作创建对象，这样的子类才能重定义它们的创建方式”，这条准则保证了子类的设计者能够在必要的时候改变父类所实例化的对象的类。

	\item Parameterized factory method.
		  
		  参数化工厂方法。

		  该模式的另一种情况使得工厂方法可以创建多种产品。工厂方法采用一个参数，用来标识要被创建的对象种类的参数。工厂方法创建所有的对象将共享Product接口。在Document例子中，Application可能支持不同种类的Document。你给CreateDocument传递一个外部参数来制定将要创建的文档的种类。

	\item Language-specific variants and isseus.

	      不同语言的变化和问题。

		  不同的语言有助于产生其他一些有趣的变化和警告。

		  Smalltalk略去

		  C++工厂方法都是虚函数并且常常是纯虚函数。一定要注意在Creator的构造器中不要调用工厂方法——在ConcreteCreator中该方法还不可用。

		  只要你使用按需创建产品的访问者操作，很小心的访问产品，你就可以避免这一点。构造器只是将产品初始化为0，而不是创建一个具体产品。访问者返回该产品。但首先它要检查确定该产品的存在，如果该产品不存在，访问者就创建它，这种技术优势被称为lazy initialization。下面的代码给出了一个典型的实现：

\begin{schemedisplay}
class Creator{
	public:
		Product* GetProduct();
	protect:
		virtual Product* CreateProduct();
	private:
		Product* _product;
		  	
};

Product* Creator::GetProduct(){
	if(_product == 0){
		_product = CreateProduct();
	}
	return _product;
}
\end{schemedisplay}

	\item Using templates to avoid subclassing.

	使用模板避免创建子类。正如我们已经提及的，工厂方法另一个潜在的问题是它们可能仅为了创建适当的Product对象而迫使你创建Creator子类。在C++中另一个解决方法是提供Creator的一个模板子类，它使用Product类作为模板参数：

\begin{schemedisplay}
class Creator{
	public:
		virtual Product* CreateProduct() = 0;
};

template <class TheProduct> class StandardCreator : public Creator{
	public:
		virtual Product* CreateProduct();
};

template <class TheProduct>
Product* StandardCreator<TheProduct>::CreateProduct(){
	return new TheProduct;
}
\end{schemedisplay}

	\item Naming conventions

	使用命名约定是一个好习惯，它可以清楚地说明你正在使用工厂方法。例如Macintosh的应用框架MacApp总是声明那些定义为工厂方法的抽象操作为Class× DoMakeClass(), 此处Class是Product类。
	
\end{enumerate}

\subsection{代码实现}

\scminput{code/Creational/FactoryMethod/Product.h}
\scminput{code/Creational/FactoryMethod/Creator.h}
\scminput{code/Creational/FactoryMethod/Creator.cpp}
\scminput{code/Creational/FactoryMethod/ConcreteCreator.h}
\scminput{code/Creational/FactoryMethod/ConcreteCreator.cpp}
\scminput{code/Creational/FactoryMethod/ConcreteProduct.h}
\scminput{code/Creational/FactoryMethod/ConcreteProduct.cpp}
\scminput{code/Creational/FactoryMethod/client.cpp}


\xrtag{Prototype}{Prototype 原型}
\section{Prototype 原型}

\subsection{Structure 结构}

\htmlpic{images/Prototype.png}

\subsection{Participants 组成}

\begin{itemize}
\small
\item \textbf{Prototype} (Graphic)

	\begin{itemize}
		\item declares an interface for cloning itself.
	\end{itemize}

\item \textbf{ConcretePrototype} (Staff, WholeNote, HalfNote)

	\begin{itemize}
		\item implents an operation for cloning itself.
	\end{itemize}

\item \textbf{Client} (GraphicTool)

	\begin{itemize}
		\item creates a new object by asking a prorotype to clone itself.
	\end{itemize}
\normalize
\end{itemize}

\subsection{Collaborations 协作}

\begin{itemize}
\item A client asks a prototype to clone itself.
\end{itemize}

\subsection{Consequences GoF评论}

Prototype has many of the same consequences that and  have: It hides the concrete product classes from the client, thereby reducing the number of names clients know about. Moreover, these patterns let a client work with application-specific classes without modification.

Prototype有许多和一样的果效：他们对客户隐藏了具体的产品类，从而减少了客户需要知道的名字。另外，这些模式使客户无需改变就可以使用和具体应用相关的类。

Additional benefits of the Prototype pattern are listed below。

额外的一些优点。

\begin{enumerate}

\item Adding and removing products at run-time.

	  在运行时增加和删除产品。
	  
	  Prototype允许只通过客户注册原型实例就可以将一个新的具体产品类并入系统。它比其它创建型模式更为灵活，因为客户可以在运行时刻建立和删除原型。

\item Specifying new objects by varying values.

      通过扩展值来指定新的对象。

	  高度动态的系统允许你通过对象复合定义新的行为——例如，通过为一个对象变量指定值——并且不定义新的类。你通过实例化已有类并且将这些实例注册为客户对象的原型，就可以有效定义新类别的对象。客户可以将职责代理给原型，从而表现出新的行为。

	  这种设计使得用户无需编程即可定义新“类”。实际上，克隆一个原型类似于实例化一个类。Prototype模式可以极大的减少系统所需要的类的数目。在我们的音乐编辑器中，一个GraphicTool类可以创建无数种音乐对象。

\item Specifying new objects by varying structure.

	  通过扩展结构来指定新的对象。

	  高度动态系统许多应用由部件和子部件来创建对象。例如电路设计编辑器就是用电路来构造电路的（这样的应用反映了Composite和Decorator模式）。为方便起见，这样的应用通常允许你实例化复杂的、用户定义的结构，比方说，一次又一次的重复使用一个特定的子电路。

	  Prototype模式也支持这一点。我们仅需将这个子电路作为一个原型增加到可用的电路元素选择板中。只要复合电路对象将Clone实现为一个深拷贝（deep copy），具有不用结构的电路就可以是原型了。

\item Reduced subclassing. 

      减少子类。

	  经常产生一个与产品类层次平行的Creator类层次。Prototype模式使得你克隆一个原型而不是请求一个工厂方法去产生一个新的对象。因此你根本不需要Creator类层次，这一优点主要适用于像C++这样不将类作为一级类对象的语言。像Smalltalk和Objective C这样的语言从中获益较少，因为你总是可以用一个类对象作为生成者。在这些语言中，类对象已经起到原型一样的作用了。

\item Configuring an application with classes dynamically.

	  用动态类配置应用。

	  一些运行时刻环境允许你动态将类装载到应用中。在像C++这样的语言中，Prototype模式是利用这种功能的关键。

	  一个希望创建动态载入类的实例的应用不能静态引用类的构造器。而应该由运行环境在载入时自动创建每个类的实例，并用原型管理器来注册这个实例。这样应用就可以向原型管理器请求装载新的类的实力，这些类原本并没有和程序相连接。ET++应用框架有一个运行系统就是使用这一方案的。

	  Prototype的主要缺陷是每一个Prototype的子类都必须实现Clone操作，这可能很困难。例如，当所考虑的类已经存在时就很难新增Clone操作。当内部操作包括一些不支持拷贝或有循环引用的对象时，实现克隆可能也会很困难的。

      因为像C++这样的静态语言，类不是对象，并且运行时刻只能得到很少或者得不到任何类型信息，所以Prototype特别与哦用。而在Smalltalk或Objective C这样的语言中Prototype就不是那么重要了，因为这些语言提供了一个等价于原型的东西（即类对象）来创建每个类的实例。Prototype模式在像Self这样既语言性的语言中是固有的，所有对象的创建都是通过克隆一个原型实现的。

	  在实现原型时，要考虑下面的一些问题：
	  
	  \begin{enumerate}

	  \item 使用一个原型管理器

	  当一个系统中原型数目不固定时（也就是说，他们可以动态创建和销毁），要保持一个可用原型的注册表。客户不会自己来管理原型，但会在注册表中存储和检索原型。客户在克隆一个原型前会向注册表请求该原型。我们称这个注册表为原型管理器（Prototype Manager）。

	  原型管理器是一个关联存储器（associative store），它返回一个与给定关键字相匹配的原型。它有一些操作可以用来通过关键字注册原型和解除注册。客户可以在运行时更或是浏览这个这个注册表，这使得客户无需编写代码就可以扩展并得到系统清单。

	  \item 实现克隆操作

	  Prototype模式最困难的部分在于正确实现Clone操作。当对象结构包含循环引用时，这尤为棘手。

	  大多数语言都对克隆对象提供了一些支持。例如，Smalltalk提供了一个copy的实现，它被所有Object的子类所继承。C++提供了一个拷贝构造器。但这些设施并不能解决“浅拷贝和深拷贝”问题，也就是说，克隆一个对象是依次克隆他的实例变量呢，或者还是由克隆对象和原对象共享这些变量？

	  浅拷贝简单并且通常也就足够了，它是Smalltalk所缺省提供的。C++中的缺省拷贝构造器实现按成员拷贝，这意味着在拷贝的和原来的对象之间是共享指针的。但克隆一个结构复杂的原型通常需要深拷贝，因为复制对象和原对象必须相互独立。因此你必须保证克隆对象的构件也是对原型的构件的克隆。克隆迫使你决定如果所有东西都被共享了该怎么办。

 	  如果系统中的对象提供了save和load操作，那么你只需要通过保存对象和立刻载入对象，就可以为clone操作提供一个缺省实现。save操作将该对象保存在内存缓冲区中，而load则通过从该缓冲区中重构这个对象来创建一个副本。

	  \item 初始化克隆对象

	  当一些客户对克隆对象已经相当满意时，另一些客户将会希望使用他们所选择的一些值来初始化该对象的一些或是所有的内部状态。一般来说不可能再clone操作中传递这些值，因为这些值的数目由于原型的类的不同而会有所不同。一些原型可能需要多个初始化参数，另一些可能什么也不需要。在Clone操作中传递参数会破坏克隆接口的统一性。

	  可能会这样，原型的类已经为（重）设定一些关键的状态值定义好了操作。如果这样的话，客户在克隆后马上就可以使用这些操作。否则，你就可能不得不引入一个Initialize操作，该操作使用初始化参数并据此设定克隆对象的内部状态。注意深拷贝clone操作——一些复制在你重新初始化它们之前可能必须要被删除掉（删除可以显式地做也可以在Initialize内部做）。

	  \end{enumerate}

\end{enumerate}

\subsection{代码实现}

\scminput{code/Creational/Prototype/Prototype.h}
\scminput{code/Creational/Prototype/PrototypeDragon.h}
\scminput{code/Creational/Prototype/PrototypeDragon.cpp}
\scminput{code/Creational/Prototype/PrototypePhoenix.h}
\scminput{code/Creational/Prototype/PrototypePhoenix.cpp}
\scminput{code/Creational/Prototype/client.cpp}

\section{Singleton 单体}

\subsection{Structure 结构}

\htmlpic{images/Singleton.png}

\subsection{Participants 组成}

\begin{itemize}
\small
	\item \textbf{Singletons}
	\begin{itemize}
	
		\item defines an Instance operation that lets clients access its unique instance. Instance is a class operation ( that is, a class method in Smalltalk and a static member function in C ).

		\item may be responsible for creating its own unique instance.

	\end{itemize}
\normalize
\end{itemize}

\subsection{Collaborations 协作}

\begin{itemize}

	\item Clients access a Singleton instance solely through Singleton's Instance operation.

\end{itemize}

\subsection{Consequences GoF评论}

The Singleton pattern has several benefits:

\begin{enumerate}

	\item Controlled access to sole instance.

	限制访问单一实例。
	
	Singleton类封装了它的唯一实例，它可以控制客户何时以及如何访问。

	\item Reduced name space.

	削减名字空间。

	Singleton模式是对全局变量的一种改进。它避免了那些存储唯一实例的全局变量污染名字空间。

	\item Permits refinement of operations and represenrarion.

	允许精炼操作和表示。

	Singleton类可以有子类，而且用这个扩展类的实例来配置一个应用是很容易的。你可以用你所需要的类的实例在运行时刻配置应用。

	\item Permits a veriable number of instances.

	允许可变数目的实例。

	这个模式使得你易于改变你的想法，并允许Singleton类出现更多的实例。此外，你可以用相同的方法来控制应用所使用的实例的个数。只有允许访问Singleton实例的操作需要改变。

	\item More flexible than class operations.

	比类操作更灵活。

	另一种封装单件功能的方法是使用类操作（即C++中静态成员函数或者Smalltalk中的类方法）。但这两种语言技术都难以改变设计以允许一个类有多个示例。此外，C++中的静态成员函数不是虚函数，因此子类不能多态的重新定义它们。

\end{enumerate}

\subsection{Implentation 实现}

Here are implementation issues to consider when using the Singleton pattern:

\begin{itemize}

\item Ensuring a unique instance.

      确保唯一的实例。

	  Singleton模式使得这个唯一实例是类的一般实例，但该类被写成只有一个实例能被创建。做到这一点的一个常用方法是将创建这个实例的操作隐藏在一个类操作（即一个静态成员函数或是一个类方法）后面，由它保证只有一个实例被创建。这个操作可以访问保存唯一实例的变量，而且它可以保证这个变量在返回值之前用这个唯一实例初始化。这种方法保证了单件在他的首次使用被创建和使用。

	  在C++中你可以用Singleton类的静态成员函数Instance来定义这个类操作。Singleton还定义了一个静态成员变量_instance，它包含了指向它的唯一实例的指针。

	  客户仅通过Instance成员函数访问这个单件。变量_instance初始化为0，而静态成员函数Instance返回该变量值，如果其值为0则用唯一实例初始化它。Instance使用惰性（lazy）初始化；它的返回值知道被第一次访问时才创建和保存。

	  \textbf{注意构造器是保护型的。试图直接实例化Singleton的客户将得到一个编译时的错误信息。这就保证了只有一个实例可以被创建。}

	  此外，因为_instance是一个指向Singleton对象的指针，Instance成员函数可以将一个指向Singleton的子类的指针赋给这个变量。见代码实现。

	  关于C++实现还有一点需要注意。将单体定义为一个全局或静态的对象，然后依赖于自动的初始化，这是不够的，有如下的三个原因：

	  \begin{enumerate}
	  \item 我们不能保证静态对象只有一个实例会被声明。

	  \item 我们可能没有足够的信息在静态初始化时实例化每一个单体。单体可能需要在程序执行中稍后被计算出来的值。

	  \item C++没有定义转换单元(translation unit)上全局对象的构造器的调用顺序。这就意味着单体之间不存在依赖关系，如果有，那么错误将是不可避免的。

	  使用全局/静态对象的实现方法还有一个缺点，它使得所有单体无论用到与否都要被创建，使用静态成员函数避免了所有这些问题。
	  \end{enumerate}

\item Subclassing the Singleton class.

	  创建Singleton类的子类。

	  主要问题与其说是定义子类不如说是建立它的唯一实例，这样客户就可以使用它。事实上，指向单体实例的变量必须用子类的实例进行初始化。最简单的技术是在Singleton的Instance操作中决定你想使用的哪一个单体。

	  另一个选择Singleton的子类的方法是将Instance的实现从父类中分离出来并把它放入子类。这就允许C++程序员在链接时刻决定单体的类（即通过链入一个包含不同实现的对象文件），但对单体的客户则隐藏这一点。

	  链接的方法在链接时刻决定了单体类的选择，这使得难以在运行时刻选择单体类。使用条件语句来决定子类更加灵活一些，但这影星限定了可能的Singleton类的集合。这两种方法不是在所有情况都足够灵活的。

	  一个更灵活的方法是使用单件注册表。可能的Singleton类的集合不使用Instance定义的，Singleton类可以根据名字在一个众所周知的注册表中注册他们的单体实例。

	  这个注册表在字符串名字和单体之间建立映射。当Instance需要一个单体是，他参考注册表根据名字请求单体。

	  这个超标查询相应的单体（如果存在的话）并返回它。这个方法使得Instance不再需要知道所有可能的Singleton类或实例。它所需要的知识所有Singleton类的一个公共的接口，该接口包括了对注册表的操作。

\begin{schemedisplay}

class Singleton
{
	public:
		static void Register( const char* name, Singleton*);
		static Singleton* Instance();

	protected:
		static Singleton* Lookup( const char* name);

	private:
		static Singleton* _instance;
		static List<NameSingletonPair>* _registry;
};

\end{schemedisplay}

	Register以给定名字注册Singleton实例。为保证注册表简单，我们将让它存储一列NameSingletonPair对象。每个NameSingletonPair将一个名字映射到一个单体。Lookup操作根据给定单体的名字进行查找。我们假定一个环境变量指定了所需要的单体的名字。

\beign{schemedisplay}

Singleton* Singleton::Instance(){
	if(_instance == 0)
		const char* singletonName = getenv(*SINGLETON*);

	_instance = Lookup(singletonName);
}

\end{schemedisplay}
	  
	Singleton类在何处注册它们自己？一种可能是在它们的构造器中。例如，MySingleton子类可以像下面这样做：

\begin{schemedisplay}

MySingleton::MySingleton(){
	Singleton::Resgister(*MySingleton*, this);
}

\end{schemedisplay}

	当然，除非实例化类否则这个构造器不会被调用，这正反映了Singleton模式试图解决的问题。在C++中我们可以定义MySingleton的一个静态实例来避免这个问题。例如我们可以在包含MySingleton实现的文件中定义：

\begin{schemedisplay}

static MySingleton theSingleton;

\end{schemedisplay}

    Singleton类不再负责创建单体，它的主要职责是使得供选择的单间对象在系统中可以被访问。静态对象方法还是有一个潜在的缺点——也就是所有可能的Singleton子类的实例都必须被创建，否则它们不会被注册。


\subsection{RelatedPatterns 相关模式}

很多模式可以使用Singleton模式实现，参见AbstractFactory、Builder和Prototype。

\section{Discussion of Creational Pattern 创建型模式的讨论}

用一个系统创建的那些对象的类对系统进行参数化有两种常用方法。一种是生成创建对象的类的子类；这对应于FactoryMethod模式。这种方法的主要缺点是，仅为了改变产品类，就可能需要创建一个新的子类。这样的改变可能是级联的。例如，如果产品的创建者本身是由一个工厂方法创建的，那么你也必须重定义它的创建者。

另一种对系统进行参数化的方法更多的依赖于对象复合：定义一个对象负责明确产品对象的类，并将它作为该系统的参数。这是AbstractFactory、Builder和Prototype模式的关键特征。所有这三个模式都涉及到创建一个新的负责创建产品对象的“工厂对象”。AbstractFactory由这个工厂对象产生多个类的对象。Builder由该工厂对象通过拷贝原型对象来创建产品对象。在这种情况下，因原型负责返回产品对象，所以工厂对象和原型是同一个对象。

考虑在Prototype模式中描述的绘图编辑器框架，可以有多种方法通过产品类来参数化GraphicTool：

\begin{itemize}

	\item 使用FactoryMethod模式，将为选择板中的每个Graphic的子类创建一个GraphicTool的子类。GraphicTool将有一个NewGraphic操作，每个GraphicTool的子类都会重定义它。

	\item 使用AbstractFactory模式，将有一个GraphicsFactory类层次对应于每个Graphic的子类。在这种情况每个工厂仅创建一个产品：CircleFactory将创建Circle，LineFactory将创建Line，等等。GraphicTools将以创建和始终类的Graphic的工厂作为参数。

	\item 使用ProtoType模式，每个Graphic的子类将实现Clone操作，并且GraphicTool将以它所创建的Graphic的原型作为参数。

\end{itemize}

究竟哪一种模式最好取决于诸多因素。在我们的绘图编辑器框架中，第一眼看来FactoryMethod模式使用是最简单的。它易于定义一个新的GraphicTool的子类，并且仅当选择半被定义了的时候，GraphicTool的实例才被创建。它的主要缺点在于GraphicTool子类数据的激增，并且它们都没有做很多事情。

AbstractFactory并没有很大的改进，因为它需要一个同样庞大的GraphicsFactory类层次。只有当早已存在一个GraphicsFactory类层次时，AbstractFactory才比FactoryMethod方法更好一点——或是因为编译器自动提供（像在Smalltalk或是Objective C中）或是因为系统的其他部分需要这个GraphicsFactory类层次。

总的来说，Prototype模式对绘图编辑框架可能是最好的，因为它仅需要为每个Graphics类实现一个Clone操作。这就减少了类的数目，并且Clone可以用于其他目的而不仅仅是纯粹的实例化（例如，一个Duplicate菜单操作）。

FactoryMethod是一个设计可以定制且只略微有一些复杂。其他设计模式需要新的类，而FactoryMethod只需要一个新的操作。人们通常将FactoryMethod作为一种标准的创建对象的方法。但是当被实例化的类根本不发生变化或当实例化出现在子类可以很容易重定义的操作中（比如在初始化操作中）时，这就并不必要了。

使用AbstractFactory、Prototype或Builder的设计甚至比使用FactoryMethod的那些设计更灵活，但他们也更加复杂。通常，设计以使用FactoryMethod开始，并且当设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化。当你在设计标准之间进行权衡的时候，了解多个模式可以给你提供更多的选择余地。


