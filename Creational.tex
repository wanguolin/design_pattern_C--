\chapter{Creational Pattern 创建型}

Creational design patterns abstract the instantiation process. They help make a system independent of how its objects are created, composed, and represented. A class creational pattern uses inheritacento vary the class that's instantiated, whereas an object creational pattern will delegate instantiation to another object.

创建型抽象了实例化的过程。他们使一个系统能够独立的创建、组合和表示。一个创建型类使用继承使其实例多样化，而一个创建型对象则将实例化委托给另一个对象。

\section{AbstractFactory - 抽象工厂}

\textbf{Also known as 别名}

Kit

\subsection{Structure 结构}

\htmlpic{images/AbstractFactory.png}

在上图中AbstractFactory、AbstractProductA和AbstractProductB这三个抽象基类，分别派生出用来产生两种实际产品A和B的类厂1和2，经由这两个类厂的CreateProductA和CreateProductB方法使用AbstractProduct所派生出的两类具体产品家族来生产A和B所下辖1-2型产品。

\subsection{Participants 组成}

\begin{itemize}
\small
\item \textbf{AbstractFactory} (WidgetFactory)

	\begin{itemize}
		\item declares an interface for operations that create abstract product objects.
	\end{itemize}

\item \textbf{ConcreteFactory} (MotiWidgetFactory, PMWidgetFactory)
	
	\begin{itemize}
		\item  operations to create concrete product objects.
	\end{itemize}

\item \textbf{AbstractProduct} (Window, ScrollBar)

	\begin{itemize}
		\item declares an interface for a type of product object.
	\end{itemize}

\item \textbf{ConcreteProduct} (MotiWindow, MotiScrollBar)

	\begin{itemize}
		\item defines a product objects to be created by the corresponding concrete factory.

		\item implents the AbstractProduct interface.
	\end{itemize}

\item \textbf{Client} 

	\begin{itemize}
		\item  uses only interfaces decleared by AbstractFactory and AbstractProduct classes.
	\end{itemize}
\normalize
\end{itemize}

\subsection{Intent 意图} 

Provide an interfact for creating families of related or dependent objects without specifying their concrete classes.

在无需指定具象接口的情况下，提供了一个接口，用来创建一族互相关联或者依赖的对象。

\subsection{Applicability 适用性}

\begin{itemize}
\item A system should be independent of how its products are created, composed and represented.

      一个应当独立创建、组合和表示的系统。

\item A system should be configured with one of multiple families of products.

      一个应当由多个产品族类中的一个所配置的系统。

\item A family of related product objects is designed to be used together, and you need to enforce this constraint.

      一个被设计成协同使用并且需要强调其约束性的产品对象族。

\item You want to provide a class library of products, and you want to reveal just their interfaces, not their implementations.

      你想提供一个只暴露接口而非实现的产品类库。
\end{itemize}

\subsection{Consequences GoF评论}

\xrtag{AbstractFactory优缺点}{AbstractFactory"优缺点"}
The AbstractFactory pattern has the following benefits and liabilities:

抽象工厂模式有着如下的便利和负担：

\begin{enumerate}

\item It isolates concrete classes.

      抽象工厂分离了接口和实现。

\item It makes exchanging product families easy.
    
      产品有产品的共同抽象基类，工厂有各自工厂的抽象基类，他们的生命周期在C++中可以通过各自的基类指针统一管理。


\item It promotes consistency among products.

      拥有共同的抽象基类不同的产品系列可以经由共同的工厂抽象基类所派生出来的不同类厂所一致。

\item Supporting new kinds of products is difficult.

      AbstractFactory这个抽象基类最初的纯虚方法限制了所能产生的对象集合，在实际开发中如果扩展产品，需要修改基类和所有派生类的代码，导致维护代价和大规模代码重新编译的代价。
\end{enumerate}

\subsection{Implentation 实现}

\begin{enumerate}

\item Fatories as Singletons.

      若是应用中需要每个产品仅有一个实例存在，可使用Singleton模式。

\item Creating the products.

      如果有多个可能的产品系列，每个可能的产品系列虽然差别很小，仍需不同的工厂实现，因此可以考虑通过复制原型创建新的产品，参考Prototype模式实现。

\item Defining extensible factories.

      鉴于\ref{AbstractFactory优缺点}中提到的维护代价，有一种不够安全和良好的编码习惯，可以在构造时刻增加入参，来区别新的对象类型。对于C++这样的强类型语言来说，如果需要与特定的派生类别进行相关操作，而该操作又不能通过抽象接口所得到，用户可能会考虑使用dynamic—_cast转换，此举并非安全，因为可能会导致转换失败，这是权宜之计。

\end{enumerate}

\subsection{代码实现}

    先用头文件定义两个抽象基类，其中抽象工厂具有两个必须在派生类中被实现，抽象基类无需实现的纯虚函数，用来留给所派生的不同的工厂用自家的创造方法来重载。考虑到对象实例可能具有不同的销毁方式，定义了虚析构。
\scminput{code/Creational/AbstractFactory/AbstractFactory.h}
\scminput{code/Creational/AbstractFactory/AbstractTeenager.h}

    接下来普青产品经理和普青程序员有着共同的抽象基类，抽象青年。
\scminput{code/Creational/AbstractFactory/NormalTeenagerPM.h}
\scminput{code/Creational/AbstractFactory/NormalTeenagerPM.cpp}
\scminput{code/Creational/AbstractFactory/NormalTeenagerProgrammer.h}
\scminput{code/Creational/AbstractFactory/NormalTeenagerProgrammer.cpp}

    同样，文青产品经理和文青程序员也有着共同的抽象基类。
\scminput{code/Creational/AbstractFactory/LiteratureTeenagerPM.h}
\scminput{code/Creational/AbstractFactory/LiteratureTeenagerPM.cpp}
\scminput{code/Creational/AbstractFactory/LiteratureTeenagerProgrammer.h}
\scminput{code/Creational/AbstractFactory/LiteratureTeenagerProgrammer.cpp}

    现在派生出来一个专门生产产品经理的工厂。
\scminput{code/Creational/AbstractFactory/PMFactory.h}
\scminput{code/Creational/AbstractFactory/PMFactory.cpp}

    再派生一个专门生产程序员的工厂。
\scminput{code/Creational/AbstractFactory/ProgrammerFactory.h}
\scminput{code/Creational/AbstractFactory/ProgrammerFactory.cpp}

    两个工厂基类类型的指针指向两种不同的工厂实例，各种青年的一个容器，构造和析构
\scminput{code/Creational/AbstractFactory/client.cpp}


\section{Builder - 构建器}

\subsection{Structure 结构}

\htmlpic{images/Builder.png}

图中Director的构造函数持有Builder基类指针，Director在构造时刻传入同样Builder指针所指向的不同派生类实例，使Director构造出来不同的具体对象。

\subsection{Participants 组成}

\begin{itemize}
\small
\item \textbf{Builder} (TextConverter)

	\begin{itemize}
		\item specifies an abstract interface for creating parts of a Product object.
	\end{itemize}

\item \textbf{ConcreteBuilder} (ASCIIConverter, TeXConverter, TextWidgetConverter)

	\begin{itemize}
		\item constructs and assembles parts of the product by implementing the Builder interface.

		\item defines and keeps track of the representation it creates.

		\item provides an interface for retrieving the product (e.g., GetASCIIText, GetTextWidget).
	\end{itemize}

\item \textbf{RTFReader}

	\begin{itemize}
		\item constructs an object using the Builder interface.
	\end{itemize}

\item \textbf{ASCIIText, TeXText, TextWidget}

	\begin{itemize}
		\item represents the complex object under construction. ConcreteBuilder builds the product's internal represrntation and defines the process by which it's assembled.

		\item includes classes that define the constituent parts, including interfaces for assembling the parts into final result.
	\end{itemize}
\normalize
\end{itemize}

\subsection{Intend 意图}

Separate the construction of a complex object from its representation so that the same construction process can create different representation.
分离复杂对象的构造和表现，以此达到通过同样构建过程创造不同表现的目的。

\subsection{Applicability 适用性}

\begin{itemize}
\item the algorithm for creating a complex object should be independent of the parts that make up the object and how they're assembled.

      当独立于对象组成和封装的某复杂对象算法。

\item the construction process must allow different representations for the object that's constructed.

      对象的构造过程必须要有不同的表现。
\end{itemize}

\subsection{Consequences GoF评论}

\begin{enumerate}

\item It lets you vary a product's internal presentation.

	  它通过给内建的导向器一个抽象接口，以达到一个构建的同时并隐藏这个产品的表示和内在结构的目的。改变产品的内在表示只需要定义一个新的构建器。

\item It isolates code for construction and representation. 

	 它的构造和表现代码是独立的。构建器模式通过封装复杂对象的构建和表示，产品更加模块化。

\item It gives you finer control over the construction process.

	  和一站式的创建型不同，构建器模式在导向器一步步的控制下完成。只有产品最终完成的时候，导向器才会从构建器中取回。构建器能够比其他创建型模式更好的反应产品的构造过程，使你能够在此过程中更好的循序控制产品构建的内在结果。

\end{enumerate}

\subsection{Implentation 实现}

Typically there's an abstract Builder class that defines an operation for each component that a director may ask it to create. The operations do nothing by default. A ConcreteBuilder class overrides operations for components it's interested in creating.

通常情况下，导向器可能会要求创建一个构建器类用来给每个组件定义一个操作。默认情况下什么都不做。一个ConcreteBuilder类重载了组件感兴趣的创建。

Here are other implementation issues to consider:

一些值得考虑的实现问题：

\begin{enumerate}

\item Assembly and contruction interface.

	  装配和构造接口。构建器通过产品形态一步步的构建产品，因此构建器类的接口必须足够通用以便于构造满足所有现实产品形态的构造。

	  一个关键问题是构造和装配过程的模型。只是简单的把构造请求追加到产品中通常已经足够，在RTF那个例子中，构建器转化下一个标记并且把它追加到已经在转换了的正文中。

	  但是一些时候你可能需要在构造以先访问部分产品。Maze的例子中，MazeBuilder允许在房间之间加门，语法分析树这样自底向上构建的树形结构就是另一个例子。在这种情况下，生成器会将子节点返给导向者，然后导向者将他们回传给构建器去创建父节点。

\item Why no abstract class for products?

	  为什么没有为产品准备抽象类？通常情况下，具体构建器产生的产品之间在表现形式上相去甚远，以至于在其间抽象出共同的基类得不偿失。在RTF那个例子里，ASCIIText和TextWidget两个对象之间看起来不象会有共同接口的样子，并不需要。因为客户通常将合适的具体的构建器配给导向者，客户就能够构建器的具体的那一个子类在使用和能够相应的处理产品。

\item Empty methods as default in Builder.

      构建器中默认为空的方法。在C++中，构建方法特地不声明为纯虚而是定义为空，这使用户只重载他们感兴趣的操作。

\end{enumerate}

\subsection{代码实现}

\scminput{code/Creational/Builder/Builder.h}
\scminput{code/Creational/Builder/ArabicBuilder.h}
\scminput{code/Creational/Builder/ArabicBuilder.cpp}
\scminput{code/Creational/Builder/EnglishBuilder.h}
\scminput{code/Creational/Builder/EnglishBuilder.cpp}
\scminput{code/Creational/Builder/Director.h}
\scminput{code/Creational/Builder/Director.cpp}
\scminput{code/Creational/Builder/Director.h}
\scminput{code/Creational/Builder/client.cpp}


\section{Factory 工厂方法}

\subsection{Structure 结构}

\htmlpic{images/Factory.png}

\textbf{ As known as 别名 }

虚构造器 ( Virtual Constructor )

\subsection{Participants 组成}

\begin{itemize}
\small

\item \textbf{Product} (Document)
	\begin{itemize}
		\item defines the interface of objects the factory method creates.
	\end{itemize}

\item \textbf{ConcreteProduct} (MyDocument)
	\begin{itemize}
		\item implements the Product interface.
	\end{itemize}

\item \textbf{Creator} (Application)
	\begin{itemize} 
		\item declares the factory method, which returns an object of type Product. Creator may also define a default Implentation of the factory method that returns a default ConcreteProduct object.

		\item may call the factory method to create a Product object.
	\end{itemize}

\item \textbf{ConcretCreator} (MyApplication)
	\begin{itemize}
		\item overrides the factory method to return an instance of a concreteProduct.
	\end{itemize}

\normalize
\end{itemize}

\subsection{Intend 意图}

Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.

定义一个创建对象的接口，让子类决定实例化哪个类。Facroty方法使一个类的实例化延迟到子类。

\subsection{Applicability 适用性}

工厂模式适用于：

\begin{itemize}

\item a class can't anticipate the class of objects it must create.
	
	  一个类无法预知他所必需创建的对象的类的时候。

\item a class wants its subclasses to specify the objects it creates.

	  一个类想要他的子类来指定他所创建的对象的时候。

\item classes delegate responsibility to one of several helper subclasses, and you want to localize the knowlege of which helper subclass is the delegate.

	  类将职责委托给一些帮助子类中的一个，并且你希望将谁是这个代理帮助子类的信息局部化。

\end{itemize}

\subsection{Consequences GoF评论}

工厂方法不再需要将特定应用相关的类绑定到你的代码中。代码只处理产品接口，虽然它可以和任何用户定义的ConcreteProduct类共同工作。

工厂方法的一个潜在缺点是客户可能必须派生Creator，以创建一个特定的ConcreteProduct对象。但当客户必须要处理类变化的其他方面，必需派生Creator时，这样也成。

下面是Factory Method模式的另外两种果效。

\begin{enumerate}

\item Provides hooks for subclasses.
      Hook子类。用工厂模式在一个类的内部创建对象总会比直接创建一个对象要灵活些。工厂方法挂接子类用以给对象提供一个扩展版本。

\item Connects parallel class hierarchies.
	  连接平衡的类层次。目前为止我们所看到的例子中，工厂方法只是被Creators调用。其实特别是在平行的类层次中，客户会发现工厂方法的用处。

	  一个类将它的一些职责委托给一个独立的类的时候，就产生了平行类层次。参考交互控制的图形图像，用鼠标对他们进行拉伸、移动或是旋转。实现这样的一些操作并不总是那么容易，这通常需要存储和更新在中间状态进行操作的一些记录。这些状态只是在操作中需要，在图形对象的最终存储时并不需要。更有甚者，不同的图形在用户操作的时候呈现不同的行为。例如，拉伸一条线段的时候可能出现的效果是移动线段的一个断点，而拉伸一个文本的时候可能会改变行距。

	  在这些限制之下，最好使用一个独立的Manipulator对象来实现交互并且保存特定的需要保存的轨迹状态。不同的图形通过使用不同的Manipuator子类来处理特殊的交互。最终Manipulator类层次平行于Figure，如图：

	  \htmlpic{images/FactoryConsequence.png}

	  Figure类提供了一个可以创建一个与Figure相对应的Manipulator的CreateManipulator工厂方法，Figure的子类重载了这个方法来返回一个恰当的Manipulator子类的实例。Figure类可以实现CreateManipulator来返回一个默认的Manipuator实例，Figure子类也可以简单的默认继承。Figure类并不需要响应Manipulator子类层次，因此他们是部分并行的。

	  注意工厂类如何定义两个类层次之间的关系，他将类之间的从属关系局部化了。
